1. 面向对象：性能好。面向过程：易维护，易复用，易扩展
2. java语言简单易学，封装继承多态，支持网络编程，跨平台，支持多线程，编译与解释并存，安全可靠
3. - .class文件->jdk中的javac编译成.java文件->jvm解释成可执行二进制机器码
   - java虚拟机jvm是运行.java字节码的虚拟机，jvm针对不同系统有特定实现，
    目的是相同的字节码，返回相同的结果，实现一次编译，到处运行
   - jre是java运行时环境，他是运行已经编译的java程序的集合，有jvm，java类库，java命令，
    和其他基础构件，jre不能创建程序
   - jdk是功能齐全的java sdk，包含jre所有的内容，能创建和编译程序，还有编译器javac和工具
4. OracleJDK和openJDK
    - a三年发布一次，b三个月发布一次
    - a部分开源，b全部开源
    - a性能更好，更稳定
    - a不会为即将发布的版本提供长期支持，用户必须更新到最新的版本来获得支持
    - a通过二进制协议许可，b通过GPL v2许可
5. - java和c++都支持封装继承多态
    - java类单继承，c++类多继承，但是java接口可以多继承
    - java有自动内存管理机制，不需要手动释放内存
    - java不提供指针直接访问内存，程序内存更安全
6. - 一个程序有多个类，但是主类只有一个，java应用程序是指包含main()方法的类，java小程序是继承JApplet或者Applet类
    - 应用程序的主类不一定是public，但是小程序必须是，主类是程序的执行入口
    - 应用程序main方法启动，小程序嵌在浏览器页面运行，调用init()或者run()启动
7. - 字符常量单引号的一个字符占2个字节，字符串常量双引号若干个字符占若干个字节
    - 字符常量相当于一个整型值，可以表达式运算，字符串常量代表一个地址值
8. 父类的构造方法和私有属性不能被继承，所以构造器constructor不能被override重写，
    但是可以被overload重载,所以一个类可以有多个构造函数
9. 重载发生在一个类中，方法名必须相同，参数类型个数顺序不同，方法返回值和访问修饰符可以不同，发生在编译时
    重写发生在父子类中，方法名和参数必须相同，返回值和抛出异常小于等于父类，访问修饰符大于等于父类，父类private方法不能重写
10. 封装把对象的属性方法私有化，提供外界可以访问的一些方法
    继承是在已有的类上建立新类，子类拥有父类所有属性和方法，但是父类私有的不能访问，子类可以扩展新的属性和方法
    多态是指程序中引用的变量编译时不确定指向哪个实例对象，必须由运行是才能确定，
    实现多态可以用继承，子类实现同一方法，或者接口，实现接口并实现
11. String是不可变的，用final修饰保存字符，线程安全，
    StringBuffer和StringBuilder可变，都是调用父类AbstractStringBuilder实现，但是StringBuffer方法调用加了同步锁，所以也是线程安全
    String每次操作都会产生新的对象，StringBuffer操作自己，StringBuilder性能比StringBuffer好一点点，但是线程不安全
12. 装箱将基本类型用引用类型包装起来，拆箱将引用类型转换为基本类型
13. 静态方法可以不通过对象调用，所以静态方法不能调用非静态变量，也不能访问非静态变量
14. java程序在执行子类构造方法的之前，如果没有通过super方法调用父类构造方法，则会调用父类的无参构造方法
15. import java和import javax都是java的api包，都只是名字，没什么区别
16. - 接口的方法默认是public，所有方法在借口内不能有实现，java8开始有默认实现，而抽象类可以有非抽象方法
    - 接口除了static和final，不能有其他变量，抽象类不一定
    - 一个类只能实现一个接口，但只能实现一个抽象类
    - 接口方法默认public，抽象类可以有其他修饰符，除了private
    - 抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是行为的规范
17. - 成员变量是属于类的，可以用public，static，private修饰，随着对象创建而存在
    局部变量属于方法的，不能被public，static，private修饰，随着方法调用而自动消失
    - 但是他们都可以被final修饰
    - 成员变量被static修饰是属于类的，不被static修饰是属于实例的，而对象在堆内存里面，局部变量在栈内存
    - 成员变量未赋初始值会自动赋默认值，而局部变量不会
18. - 线程和进程类似，线程是比进程最小的执行单位，一个进程在运行中产生多个线程，同类线程共享内存空间和系统资源，
    产生线程或者在多个线程切换，系统负担比进程小，所以线程也被称为轻量级进程
    - 程序是含有指令和数据的文件，被保存在磁盘或其他存储设备当中，程序是静态的代码
    - 进程是程序的一次执行过程，是系统运行程序的基本单位，进程是动态的，系统运行一个程序即是一个进程从创建，
    运行，到消亡的过程。一个进程就是一个执行当中的程序，他在计算机当中一个指令一个指令执行，同时，
    每个指令还会占用系统资源如cpu，时间，文件，内存空间，输入输出设备。换句话说，当程序在执行时，
    将会被操作系统载入内存中，线程是进程划分成更小的运行单位，线程和进程最大的不同是进程是相互独立的，
    而线程可能会互相影响。从另一角度说，进程属于操作系统范畴，主要是同一时间内，可以同时执行一个以上的程序，
    而线程则是在同一程序内几乎同时执行一个以上程序段。
19. java线程在运行的生命周期里面只能处于下面6种状态的一种
    - NEW：初始状态，线程被构建，但还没有调用start()方法
    - RUNNABLE：运行状态
    - BLOCKED：阻塞状态，阻塞于锁
    - WAITING：等待状态，需要等待其他线程做出特定动作，通知或中断
    - TIME-WAITING：超时等待状态，可以在指定时间自动返回
    - TERMINATED：终止状态
20. final用在变量，方法，类上，修饰基本数据类型变量，表示数值初始化不能更改，修饰引用类型变量，表示引用的对象不能更改
    final修饰类，表示类不能被继承，该类成员方法隐式为final方法。
    final可以防止继承类修改它的含义，还有早期可以提高效率，现在不需要了
21. java异常的祖先Throwable类，有2个子类，Error，程序无法处理的错误，Exception，程序本身可以处理的异常
    try：用于捕获异常，可以接一个或多个catch，如果没有catch，则必须接finally
    catch：用于处理try捕获的异常
    finally：无论是否捕获或处理异常，finally都会被执行
    try或者catch有return语句，finally在return前执行
    try和finally都有return语句，finally的return会覆盖try的return的值
    finally在下面4种情况不会被执行
    - finally第一行异常
    - 前面代码中有System.exit(int)已经退出程序
    - 线程死亡
    - 关闭cpu
21. servlet负责接收用户请求httpServletRequest，在doGet()和doPost()中做处理，并返回httpServletResponse，
    servlet可以设置初始化参数，供内部使用，一个servlet只有一个实例，一个servlet可以由多个url访问，所以servlet不是线程安全
    servlet5个方法：init()，service()，destroy()，getServletInfo()，getServletConfig()，
    生命周期：web容器加载servlet并实例化，servlet生命周期开始，容器运行init()方法进行servlet的初始化，
    请求到达时调用service()方法，service()根据需求调用doGet()或者doPost()，当服务关闭会调用destroy()销毁，
    init和destroy只会执行一次，service客户端每次请求都会执行一次。servlet有时候会用到需要初始化和销毁的资源，
    所以会把初始化资源放在init，销毁资源放在destroy，这样就不需要每次请求都调用。
22. - 转发Forward是服务器行为，重定向Redirect是客户端行为
    - 转发通过RequestDispatcher对象的forward(HttpServletRequest request,HttpServletResponse response)方法实现，
    RequestDispatcher可以通过request.getRequestDispatcher()方法获得
    - 重定向是通过服务器返回的状态码实现，客户端浏览器请求服务器的时候，服务器会返回一个状态码。
    服务器通过HttpServletResponse的setStatus(int status)方法设置状态码，如果服务器返回301或者302，
    则浏览器会到新的网址请求资源
    - 转发是服务器请求资源，服务器直接访问url，读到响应内容返回给浏览器，浏览器不知道内容从哪来，所以地址栏还是原来的。
    重定向是服务端根据逻辑，发送一个状态码，告诉浏览器去请求新地址，所以地址栏是新地址
    - 转发可以共享request的数据，重定向不可以
    - 转发一般用于用户登录，根据角色发送到对应的模块，重定向一般用于用户注销时返回主页和跳转其他页面
    - 转发效率比重定向高
23. Java位运算符
    - 左移(<<)、右移(>>)、无符号右移(>>>)、位与(&)、位或(|)、位非(~)、位异或(^)
    - 位非(~)是一元操作符，其它都是二元操作符
    - 负数（绝对值取反码再加一）
    - 二进制首位是符号位，0表示正数，1表示负数
    - 左移(<<)：左移n位，低位补0
    - 右移(>>)：右移n位，高位补符号位，正数高位补0，负数高位补1
    - 无符号右移(>>>)：无符号右移，负数用0补(由负数变成正数)，正数也一样用0补
    - 位与(&)：都是1则为1，否则为0
    - 位或(|)：有一个1则为1，否则为0
    - 位异或(^)：相反则为1，否则为0
    - 位非(~)：位非是一元操作符，取反




















